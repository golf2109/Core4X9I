# Core4X9I
* Отладочная плата от WaveShare Core4X9I c
контроллером STM32f429IG.
* LCD модуль со встроенным контроллером SSD1963 управление по 16 битной шине (RGB565) через встроенный 
модуль контроллера FMC в режиме NAND Flash.
* Тач контроллер TSC2046 через SPI2 (stm32) частота spi интерфейса 1,4MHz.
* Используется микросхема SDRAM  IS42S16400  1Meg Bits x 16 Bits x 4 Banks (64-MBIT)
частота интерфейса AHB 90MHz. SDRAM подключена  к FMC_SDRAM_Bank2  адрес SDRAM_BASE=0x90000000.
* Heap emWin располагается с адреса 0xD010 0000 до 0xD019 D7FF ( 630 * 1024 байт).
* SPI FLASH (MX25L8005) через интерфейс SPI1 11,25MHz (STM32). Все битмапы иконок храняться в ней и при старте копируются
в SDARM по адресу 0xD00B0000-0xD00BCBAB (50 * 1024)  и далее рисуются из SDRAM. Файл с картой распределения памяти
memory_map.xls.
* sd карта подключена по 4-х битному интерфейсу SDIO  SDIOCLK=(48MHz) / 2=24MHz.
Карта работает через DMA2_Stream3. Один на прием и на передачу. Драйвер карты настроен на байтную адресацию (SDSC 1,2 Gb).
* Поверх функций чтения/записи сектора реализованы функции disc_read disc_write из библиотеки FATFs (Chan's).
Вся работа с картой чтение запись файлов посредством файловой системы FATFS.
* Настроен модуль для приема сообщений по CAN сети (CAN1). Частота 125 KHz Sample point=75%.Транссивер CAN шины
SN65HVD230.
* На таймере TIM2 сделан модуль управления тиристором для регулирования мощности нагрузки (нагреватель).
2 режима работы таймера фазовый и по методу брезенхема.Таймер в режиме One pulse mode.Длительность импульса для открывания
тиристора 300 мкс.
  * Фазовый реализует изменение фазы включения тиристора на каждом полупериоде
сетевого напряжения изменяя мощность нагрузки 0-100% с шагом 1%. Таймер запускается  по сигналу с детектора перехода 
"фазы" через "ноль". В таком режиме таймер генерит импульсы  автономно без прерываний.
  * Брезенхема реализует изменение мощности путем пропусков целых периодов синусойды сетевого напряжения.
Для этого включается прерывание для таймера по событию capture от детектора "фазы через ноль".
Через биты IC1PSC регистра CCMR1 прерывание по захвату срабатывает на каждом втором импульсе.Таким
образом  делается пропуск целых периодов синусойды для регулирования. Мощность регулируется 0-100 %
но в таком режиме шаг равен 2% (50 делений по мощности)

* 03.03.17 Добавил возможность обновления по CAN сети в режиме приложения. Управляющий MCU присылает запрос на обновление в виде
сообщения id=271 UPDATE_FIRMWARE_REQ сообщение содержит размер бинарника который сохраняется в size_firmware. Далее разблокируется
флэш если надо очищаются необходимае сектора (с адреса NAMBER_UPD_SECTOR ) и отправляется подтверждение на выдачу данных 
   * ID=(NETNAME_INDEX<<8)|0x72
   * CAN_Data_TX.Data[0]=NETNAME_INDEX
   * CAN_Data_TX.Data[1]='g'					GET_DATA.
- Далее принимаются сообщения по 8 байт прошивки для обновления с индексом id=273 DOWNLOAD_FIRMWARE и записываются во вторую 
половину флэш. После принятия всех байт проверяется целостность записанной прошивки crc32_check() и выдаются сообщение содержащее 
CAN_Data_TX.Data[1]='c' если CRC_OK! или CAN_Data_TX.Data[1]='e' если CRC_ERROR! Выставляется флаг write_flashflag=1 если CRC_OK!
В сеторе FLAG_STATUS_SECTOR перебираются байты пока не будет найдено чистое поле 0xFF. В этом байте пишется флаг 0xA7 для бутлодера, 
который перепишет обновление в рабочую часть флэш и сделает запуск приложения. После секндной паузы делается RESET для запуска бутлоадера.
* Для получения готового bin файла делается последовательность:

  * $K\ARM\ARMCC\BIN\fromelf.exe --bin -o Core4x9I.bin !L получаем из .axf бинарник .bin
  * srec_cat Core4x9I.bin -bin -exclude 0x1C 0x28 -length-l-e 0x1C 4 -generate 0x20 0x28 -repeat-string Core4x9I -o Core4x9I.bin -bin - исключаем из бинарника адреса с 0x1C до 0x28 по адресу 0x1c записываем 4 байта размер бинарника. По адресу 0x20 8 байт строки "Core4x9I"
  * srec_cat Core4x9I.bin -bin -crc32-l-e -max-addr Core4x9I.bin -bin -o Core4x9I.bin - считаем crc32 для полученного бинарника и сохраняем его в конце файла Core4x9I.bin.
